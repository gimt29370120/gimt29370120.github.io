<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>透視校正</title>
<style>
  canvas { border:1px solid #333; cursor:crosshair; }
  .row { margin:8px 0; }
</style>
</head>
<body>

<div class="row">
  <input type="file" id="upload" accept="image/*">
</div>

<!-- 顯示用 canvas（含紅點） -->
<canvas id="viewCanvas"></canvas>

<!-- 隱藏的原始圖片 canvas（無紅點，僅供輸出使用） -->
<canvas id="srcCanvas" style="display:none"></canvas>

<div class="row">
  輸出比例：
  <input id="ratio" value="1:1" style="width:60px">
</div>

<div class="row">
  <button id="process">開始處理</button>
</div>

<h3>輸出圖片</h3>
<canvas id="outputCanvas"></canvas>

<script>
const upload = document.getElementById('upload');
const viewCanvas = document.getElementById('viewCanvas');
const srcCanvas  = document.getElementById('srcCanvas');
const outCanvas  = document.getElementById('outputCanvas');
const HANDLE_SIZE = 30;
const BORDER_COLOR = '#6bbcff';

const vctx = viewCanvas.getContext('2d');
const sctx = srcCanvas.getContext('2d');
const octx = outCanvas.getContext('2d');

let img = new Image();
let points = [];
let dragging = -1;

upload.onchange = e => {
  img.src = URL.createObjectURL(e.target.files[0]);
};

img.onload = () => {
  const w = img.width;
  const h = img.height;

  // canvas 尺寸完全等於圖片尺寸
  viewCanvas.width = srcCanvas.width = w;
  viewCanvas.height = srcCanvas.height = h;

  // 四角控制點
  points = [
    {x:0,y:0},
    {x:w,y:0},
    {x:w,y:h},
    {x:0,y:h}
  ];

  draw();
};

function draw() {
  // 圖片
  vctx.clearRect(0,0,viewCanvas.width,viewCanvas.height);
  vctx.drawImage(img,0,0);

  /* ---- 虛線連接四點 ---- */
  vctx.save();
  vctx.strokeStyle = '#6bbcff';
  vctx.lineWidth = 2;
  vctx.setLineDash([6,4]);

  vctx.beginPath();
  points.forEach((p,i)=>{
    if(i===0) vctx.moveTo(p.x,p.y);
    else vctx.lineTo(p.x,p.y);
  });
  vctx.closePath();
  vctx.stroke();
  vctx.restore();

  /* ---- 拖曳控制點 ---- */
  points.forEach(p=>{
    const s = HANDLE_SIZE;
    const x = p.x - s/2;
    const y = p.y - s/2;

    // 半透明白色填充
    vctx.fillStyle = 'rgba(255,255,255,0.6)';
    vctx.fillRect(x,y,s,s);

    // 淺藍色邊框
    vctx.strokeStyle = '#6bbcff';
    vctx.lineWidth = 2;
    vctx.strokeRect(x,y,s,s);
  });

  /* 原始 canvas（輸出用） */
  sctx.clearRect(0,0,srcCanvas.width,srcCanvas.height);
  sctx.drawImage(img,0,0);
}

viewCanvas.onmousemove = e => {
  if(dragging < 0) return;
  const r = viewCanvas.getBoundingClientRect();
  points[dragging].x = e.clientX - r.left;
  points[dragging].y = e.clientY - r.top;
  draw();
};

viewCanvas.onmousedown = e => {
  const r = viewCanvas.getBoundingClientRect();
  const x = e.clientX - r.left;
  const y = e.clientY - r.top;

  points.forEach((p,i)=>{
    const s = HANDLE_SIZE;
    if (
      x >= p.x - s/2 && x <= p.x + s/2 &&
      y >= p.y - s/2 && y <= p.y + s/2
    ) {
      dragging = i;
    }
  });
};


viewCanvas.onmouseup = ()=> dragging = -1;

/* --- 開始處理 --- */
document.getElementById('process').onclick = () => {
  const [rw,rh] = document.getElementById('ratio').value.split(':').map(Number);
  const outW = 600;
  const outH = Math.round(outW * rh / rw);

  outCanvas.width = outW;
  outCanvas.height = outH;

  perspectiveTransform(srcCanvas, points, outCanvas);
};

/* --- 透視校正（四邊形 → 矩形）--- */
function perspectiveTransform(srcCanvas, srcPts, dstCanvas) {
  const sw = srcCanvas.width, sh = srcCanvas.height;
  const dw = dstCanvas.width, dh = dstCanvas.height;

  const src = srcCanvas.getContext('2d').getImageData(0,0,sw,sh);
  const dst = dstCanvas.getContext('2d').createImageData(dw,dh);

  for(let y=0;y<dh;y++){
    for(let x=0;x<dw;x++){
      const u = x / dw;
      const v = y / dh;

      const sx =
        (1-u)*(1-v)*srcPts[0].x +
        u*(1-v)*srcPts[1].x +
        u*v*srcPts[2].x +
        (1-u)*v*srcPts[3].x;

      const sy =
        (1-u)*(1-v)*srcPts[0].y +
        u*(1-v)*srcPts[1].y +
        u*v*srcPts[2].y +
        (1-u)*v*srcPts[3].y;

      const ix = Math.floor(sx);
      const iy = Math.floor(sy);
      if(ix<0||iy<0||ix>=sw||iy>=sh) continue;

      const si = (iy*sw+ix)*4;
      const di = (y*dw+x)*4;
      for(let k=0;k<4;k++)
        dst.data[di+k] = src.data[si+k];
    }
  }
  dstCanvas.getContext('2d').putImageData(dst,0,0);
}
</script>

</body>
</html>
