<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>透視校正</title>
<style>
  body { margin: 0; font-family: sans-serif; }
  canvas {
    border: 1px solid #333;
    max-width: 100%;
    height: auto;
    touch-action: none;
    display: block;
    margin-bottom: 8px;
  }
  .row { margin: 8px 0; }
</style>
</head>
<body>

<div class="row">
  <input type="file" id="upload" accept="image/*">
</div>

<canvas id="viewCanvas"></canvas>
<canvas id="srcCanvas" style="display:none"></canvas>

<div class="row">
  輸出比例：
  <input id="ratio" value="1:1" style="width:60px">
</div>

<div class="row">
  <button id="process">開始處理</button>
  <button id="download">下載圖片</button>
</div>

<h3>輸出圖片</h3>
<canvas id="outputCanvas"></canvas>

<script>
const upload = document.getElementById('upload');
const viewCanvas = document.getElementById('viewCanvas');
const srcCanvas  = document.getElementById('srcCanvas');
const outCanvas  = document.getElementById('outputCanvas');

const vctx = viewCanvas.getContext('2d');
const sctx = srcCanvas.getContext('2d');
const octx = outCanvas.getContext('2d');

const HANDLE_SIZE = 30;

let img = new Image();
let points = [];
let dragging = -1;

/* ===== 座標轉換（你原本那組，保留）===== */
function scaleX() {
  return viewCanvas.width / viewCanvas.getBoundingClientRect().width;
}
function scaleY() {
  return viewCanvas.height / viewCanvas.getBoundingClientRect().height;
}
function getCanvasPos(e) {
  const r = viewCanvas.getBoundingClientRect();
  const t = e.touches ? e.touches[0] : e;
  return {
    x: (t.clientX - r.left) * scaleX(),
    y: (t.clientY - r.top) * scaleY()
  };
}

/* ===== 載入圖片 ===== */
upload.onchange = e => {
  img.src = URL.createObjectURL(e.target.files[0]);
};

img.onload = () => {
  const w = img.width;
  const h = img.height;

  viewCanvas.width = srcCanvas.width = w;
  viewCanvas.height = srcCanvas.height = h;

  points = [
    {x:0,y:0},
    {x:w,y:0},
    {x:w,y:h},
    {x:0,y:h}
  ];

  draw();
};

/* ===== 繪製 ===== */
function draw() {
  vctx.clearRect(0,0,viewCanvas.width,viewCanvas.height);
  vctx.drawImage(img,0,0);

  const sx = scaleX();
  const sy = scaleY();

  vctx.save();
  vctx.scale(1/sx, 1/sy);

  const drawPts = points.map(p=>({
    x: p.x * sx,
    y: p.y * sy
  }));

  /* 虛線 */
  vctx.setLineDash([6,4]);
  vctx.lineWidth = 2;
  vctx.strokeStyle = '#6bbcff';
  vctx.beginPath();
  drawPts.forEach((p,i)=>{
    if(i===0) vctx.moveTo(p.x,p.y);
    else vctx.lineTo(p.x,p.y);
  });
  vctx.closePath();
  vctx.stroke();
  vctx.setLineDash([]);

  /* 控制點 */
  drawPts.forEach(p=>{
    vctx.fillStyle='rgba(255,255,255,0.7)';
    vctx.fillRect(p.x-15,p.y-15,30,30);
    vctx.strokeStyle='#6bbcff';
    vctx.strokeRect(p.x-15,p.y-15,30,30);
  });

  vctx.restore();

  sctx.clearRect(0,0,srcCanvas.width,srcCanvas.height);
  sctx.drawImage(img,0,0);
}

/* ===== 拖曳事件（滑鼠＋觸控）===== */
function startDrag(e){
  const {x,y} = getCanvasPos(e);
  dragging = -1;
  points.forEach((p,i)=>{
    if (
      x >= p.x - HANDLE_SIZE/2 &&
      x <= p.x + HANDLE_SIZE/2 &&
      y >= p.y - HANDLE_SIZE/2 &&
      y <= p.y + HANDLE_SIZE/2
    ) dragging = i;
  });
}

function moveDrag(e){
  if(dragging < 0) return;
  e.preventDefault();
  const {x,y} = getCanvasPos(e);
  points[dragging].x = x;
  points[dragging].y = y;
  draw();
}

function endDrag(){ dragging = -1; }

viewCanvas.addEventListener('mousedown', startDrag);
viewCanvas.addEventListener('mousemove', moveDrag);
viewCanvas.addEventListener('mouseup', endDrag);

viewCanvas.addEventListener('touchstart', startDrag, {passive:false});
viewCanvas.addEventListener('touchmove', moveDrag, {passive:false});
viewCanvas.addEventListener('touchend', endDrag);

/* ===== 透視校正 ===== */
document.getElementById('process').onclick = () => {
  const [rw,rh] = document.getElementById('ratio').value.split(':').map(Number);
  const outW = 800;
  const outH = Math.round(outW * rh / rw);

  outCanvas.width = outW;
  outCanvas.height = outH;

  perspectiveTransform(srcCanvas, points, outCanvas);
};

function perspectiveTransform(srcCanvas, srcPts, dstCanvas) {
  const sw = srcCanvas.width, sh = srcCanvas.height;
  const dw = dstCanvas.width, dh = dstCanvas.height;

  const src = sctx.getImageData(0,0,sw,sh);
  const dst = octx.createImageData(dw,dh);

  for(let y=0;y<dh;y++){
    for(let x=0;x<dw;x++){
      const u = x / dw;
      const v = y / dh;

      const sx =
        (1-u)*(1-v)*srcPts[0].x +
        u*(1-v)*srcPts[1].x +
        u*v*srcPts[2].x +
        (1-u)*v*srcPts[3].x;

      const sy =
        (1-u)*(1-v)*srcPts[0].y +
        u*(1-v)*srcPts[1].y +
        u*v*srcPts[2].y +
        (1-u)*v*srcPts[3].y;

      const ix = Math.floor(sx);
      const iy = Math.floor(sy);
      if(ix<0||iy<0||ix>=sw||iy>=sh) continue;

      const si = (iy*sw+ix)*4;
      const di = (y*dw+x)*4;
      for(let k=0;k<4;k++)
        dst.data[di+k] = src.data[si+k];
    }
  }
  octx.putImageData(dst,0,0);
}

/* ===== 下載 ===== */
document.getElementById('download').onclick = ()=>{
  const a = document.createElement('a');
  a.download = 'output.png';
  a.href = outCanvas.toDataURL();
  a.click();
};
</script>
</body>
</html>
